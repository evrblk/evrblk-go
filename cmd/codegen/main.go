package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	. "github.com/dave/jennifer/jen"
)

func main() {
	clients := []clientDesc{
		{
			serviceName:   "Grackle",
			goPackagePath: "github.com/evrblk-go/grackle/preview",
			goPackageName: "grackle",
			outputPath:    "./grackle/preview/client.go",
			protoFilePath: "./proto/grackle/preview/api.proto",
		},
		{
			serviceName:   "IAM",
			goPackagePath: "github.com/evrblk-go/iam/preview",
			goPackageName: "iam",
			outputPath:    "./iam/preview/client.go",
			protoFilePath: "./proto/iam/preview/api.proto",
		},
		{
			serviceName:   "Moab",
			goPackagePath: "github.com/evrblk-go/moab/preview",
			goPackageName: "moab",
			outputPath:    "./moab/preview/client.go",
			protoFilePath: "./proto/moab/preview/api.proto",
		},
		{
			serviceName:   "MyAccount",
			goPackagePath: "github.com/evrblk-go/myaccount/preview",
			goPackageName: "myaccount",
			outputPath:    "./myaccount/preview/client.go",
			protoFilePath: "./proto/myaccount/preview/api.proto",
		},
	}

	for _, client := range clients {
		out, err := os.Create(client.outputPath)
		if err != nil {
			log.Fatalf("failed to create output file: %v", err)
		}
		defer out.Close()

		serviceDescs, err := ReadProtoFileAndExtractServices(client.protoFilePath)
		if err != nil {
			log.Fatalf("Error: %v\n", err)
		}

		_, err = fmt.Fprint(out, generateClient(client.serviceName, client.goPackagePath, client.goPackageName, serviceDescs[0]))
		if err != nil {
			log.Fatalf("failed to generate client: %v", err)
		}
	}
}

type clientDesc struct {
	serviceName   string
	goPackagePath string
	goPackageName string
	outputPath    string
	protoFilePath string
}

func generateClient(serviceName string, packagePath string, packageName string, serviceDesc ProtoServiceDesc) string {
	f := NewFilePathName(packagePath, packageName)
	f.HeaderComment("Code generated by `go run ./cmd/codegen`. DO NOT EDIT.")
	f.ImportAlias("github.com/evrblk/evrblk-go", "evrblk")

	apiType := serviceName + "Api"
	grpcClientType := serviceName + "GrpcClient"
	s := strings.Split(serviceDesc.ServiceName, ".")
	grpcServiceName := s[len(s)-1]

	// API interface
	f.Type().Id(apiType).InterfaceFunc(func(g *Group) {
		for _, m := range serviceDesc.Methods {
			g.Id(m.MethodName).Params(
				Id("ctx").Qual("context", "Context"),
				Id("request").Op("*").Id(m.MethodName+"Request"),
			).Params(
				List(
					Op("*").Id(m.MethodName+"Response"),
					Error(),
				),
			)
		}
	})

	// gRPC client struct
	f.Type().Id(grpcClientType).Struct(
		Id("grpc").Id(grpcServiceName+"Client"),
		Id("conn").Op("*").Qual("google.golang.org/grpc", "ClientConn"),
		Id("signer").Qual("github.com/evrblk/evrblk-go", "RequestSigner"),
	)
	f.Line()

	// API interface var
	f.Var().Id("_").Id(apiType).Op("=").Op("&").Id(grpcClientType).Values()
	f.Line()

	// WithSigner func
	f.Func().Params(
		Id("c").Op("*").Id(grpcClientType),
	).Id("WithSigner").Params(
		Id("signer").Qual("github.com/evrblk/evrblk-go", "RequestSigner"),
	).Params(
		Op("*").Id(grpcClientType),
	).Block(
		Return(Op("&").Id(grpcClientType).Values(Dict{
			Id("grpc"):   Id("c").Dot("grpc"),
			Id("conn"):   Id("c").Dot("conn"),
			Id("signer"): Id("signer"),
		})),
	)
	f.Line()

	// Close func
	f.Func().Params(
		Id("c").Op("*").Id(grpcClientType),
	).Id("Close").Params().Params().Block(
		Id("c").Dot("conn").Dot("Close").Call(),
	)
	f.Line()

	// gRPC methods
	for _, m := range serviceDesc.Methods {
		f.Func().Params(
			Id("c").Op("*").Id(grpcClientType),
		).Id(m.MethodName).Params(
			Id("ctx").Qual("context", "Context"),
			Id("request").Op("*").Id(m.MethodName+"Request"),
		).Params(
			Op("*").Id(m.MethodName+"Response"),
			Error(),
		).Block(
			// Increment TotalRequestsCounter metric
			Qual("github.com/evrblk/evrblk-go/internal", "TotalRequestsCounter").
				Dot("WithLabelValues").Call(Lit(serviceName), Lit(m.MethodName)).Dot("Inc").Call(),

			// Measure RequestsDuration metric
			Defer().Qual("github.com/evrblk/evrblk-go/internal", "MeasureSince").Call(
				Qual("github.com/evrblk/evrblk-go/internal", "RequestsDuration").
					Dot("WithLabelValues").Call(Lit(serviceName), Lit(m.MethodName)),
				Qual("time", "Now").Call(),
			),
			Line(),

			// Sign request and update context
			List(Id("signedCtx"), Err()).Op(":=").Id("c").Dot("signer").Dot("Sign").Call(
				Id("ctx"), Id("request"),
			),
			If(
				Err().Op("!=").Nil(),
			).Block(
				Return(List(Nil(), Err())),
			),
			Line(),

			// Call gRPC method
			List(Id("resp"), Err()).Op(":=").Id("c").Dot("grpc").Dot(m.MethodName).Call(
				Id("signedCtx"),
				Id("request"),
				Qual("google.golang.org/grpc", "WaitForReady").Call(True()),
			),

			If(
				Err().Op("!=").Nil(),
			).Block(
				// Increment FailedRequestsCounter metric
				Qual("github.com/evrblk/evrblk-go/internal", "FailedRequestsCounter").Dot("WithLabelValues").
					Call(
						Lit(serviceName),
						Lit(m.MethodName),
						Qual("github.com/evrblk/evrblk-go/internal", "MetricLabelFromGrpcError").Call(Err()),
					).Dot("Inc").Call(),
			),
			Line(),

			Return(
				List(Id("resp"), Qual("github.com/evrblk/evrblk-go/internal", "ErrorFromRpcError").Call(Err())),
			),
		)
		f.Line()
	}

	// New gGRPC client func
	f.Func().Id("New"+grpcClientType).Params(
		Id("address").String(),
		Id("signer").Qual("github.com/evrblk/evrblk-go", "RequestSigner"),
	).Params(
		Op("*").Id(grpcClientType),
	).Block(
		List(Id("conn"), Err()).Op(":=").Qual("google.golang.org/grpc", "NewClient").Call(
			Id("address"),
			Qual("google.golang.org/grpc", "WithTransportCredentials").Call(
				Qual("google.golang.org/grpc/credentials/insecure", "NewCredentials").Call(),
			),
		),
		If(
			Err().Op("!=").Nil(),
		).Block(
			Qual("log", "Fatalf").Call(Lit("did not connect: %v"), Err()),
		),
		Return(
			Op("&").Id(grpcClientType).Values(Dict{
				Id("conn"):   Id("conn"),
				Id("grpc"):   Id("New" + grpcServiceName + "Client").Call(Id("conn")),
				Id("signer"): Id("signer"),
			}),
		),
	)
	f.Line()

	return fmt.Sprintf("%#v", f)
}
